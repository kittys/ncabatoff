package vlib

import (
	"fmt"
	"image"
	"time"

	"github.com/BurntSushi/xgbutil"
	"github.com/BurntSushi/xgbutil/xgraphics"
	"github.com/golang/glog"
)

// chans is a group of channels used to communicate with the canvas goroutine.
type chans struct {
	// drawChan is sent a function that transforms the current origin point
	// and paints the image generated by that origin.
	drawChan chan func(pt image.Point) image.Point

	// resizeToImageChan, when pinged, will resize the window to fit the
	// current image exactly.
	resizeToImageChan chan struct{}

	// prevImg can be pinged to cycle to the previous image. It wraps.
	prevImg chan struct{}

	// nextImg can be pinged to cycle to the next image. It wraps.
	nextImg chan struct{}

	// The pan{Start,Step,End}Chan types facilitate panning. They correspond
	// to "drag start", "drag step", and "drag end."
	panStartChan chan image.Point
	panStepChan  chan image.Point
	panEndChan   chan image.Point
}

type ImageFetcher func(i int) (int, []image.Image)

type canv struct {
	chans
	imgs []*xgraphics.Image
	wins []*window
	panStart image.Point
	panOrigin image.Point
	current int
	origin image.Point
	name string
	imageFetcher ImageFetcher
	X *xgbutil.XUtil
}

func (c *canv) clearimgs() {
	for i := range c.imgs {
		if c.imgs[i] != nil {
			c.imgs[i].Destroy()
			c.imgs[i] = nil
		}
	}
}

func (c *canv) setImage(i int, pt image.Point) {
	if c.current != i || len(c.imgs) == 0 {
		c.name = fmt.Sprintf("%d", i)
		newi, newimgs := c.imageFetcher(i)
		c.current = newi

		//	window.ClearAll()
		c.clearimgs()
		c.imgs = c.imgs[:0]

		for _, img := range newimgs {
			c.imgs = append(c.imgs, draw(xgraphics.NewConvert(c.X, img)))
		}
	}
	if len(c.wins) == 0 {
		for i := 0; i < len(c.imgs); i++ {
			win := newWindow(c.X, c.imgs[i].Bounds().Dx(), c.imgs[i].Bounds().Dy())
			win.setupEventHandlers(c.chans)
			c.wins = append(c.wins, win)
		}
	}

	if pt != image.ZP && pt != c.origin {
		c.origin = originTrans(pt, c.wins[0], c.imgs[0])
	}
	c.show()
}

func (c *canv) run() {
	c.setImage(c.current, c.origin)
	for {
		sstart := time.Now()
		select {
		case funpt := <-c.drawChan:
			logsince(sstart, "received draw request %v", funpt)
			c.setImage(c.current, funpt(c.origin))
		case <-c.resizeToImageChan:
			logsince(sstart, "received resize request request")
			rect := c.imgs[0].Bounds()
			for _, win := range c.wins {
				win.Resize(rect.Dx(), rect.Dy())
			}
		case <-c.prevImg:
			logsince(sstart, "received prevImg request")
			c.setImage(c.current-1, c.origin)
		case <-c.nextImg:
			logsince(sstart, "received nextImg request")
			c.setImage(c.current+1, c.origin)
		case pt := <-c.panStartChan:
			c.panStart = pt
			c.panOrigin = c.origin
		case pt := <-c.panStepChan:
			xd, yd := c.panStart.X-pt.X, c.panStart.Y-pt.Y
			c.setImage(c.current,
				image.Point{xd + c.panOrigin.X, yd + c.panOrigin.Y})
		case <-c.panEndChan:
			c.panStart, c.panOrigin = image.Point{}, image.Point{}
		}
	}
}

// canvas is meant to be run as a single goroutine that maintains the state
// of the image viewer. It manipulates state by reading values from the channels
// defined in the 'chans' type.
func Canvas(X *xgbutil.XUtil, getImages ImageFetcher) chans {
	chans := chans{
		drawChan:          make(chan func(pt image.Point) image.Point, 0),
		resizeToImageChan: make(chan struct{}, 0),
		prevImg:           make(chan struct{}, 0),
		nextImg:           make(chan struct{}, 0),
		panStartChan:      make(chan image.Point, 0),
		panStepChan:       make(chan image.Point, 0),
		panEndChan:        make(chan image.Point, 0),
	}
	canv := canv {
		chans: chans,
		imageFetcher: getImages,
		X: X,
	}

	// defer func() { clearimgs() }()

	go canv.run()

	return chans
}

// originTrans translates the origin with respect to the current image and the
// current canvas size. This makes sure we never incorrect position the image.
// (i.e., panning never goes too far, and whenever the canvas is bigger than
// the image, the origin is *always* (0, 0).
func originTrans(pt image.Point, win *window, img *xgraphics.Image) image.Point {
	// If there's no valid image, then always return (0, 0).
	if img == nil {
		return image.Point{0, 0}
	}

	// Quick aliases.
	ww, wh := win.Geom.Width(), win.Geom.Height()
	dw := img.Bounds().Dx() - ww
	dh := img.Bounds().Dy() - wh

	// Set the allowable range of the origin point of the image.
	// i.e., never less than (0, 0) and never greater than the width/height
	// of the image that isn't viewable at any given point (which is determined
	// by the canvas size).
	pt.X = min(img.Bounds().Min.X+dw, max(pt.X, 0))
	pt.Y = min(img.Bounds().Min.Y+dh, max(pt.Y, 0))

	// Validate origin point. If the width/height of an image is smaller than
	// the canvas width/height, then the image origin cannot change in x/y
	// direction.
	if img.Bounds().Dx() < ww {
		pt.X = 0
	}
	if img.Bounds().Dy() < wh {
		pt.Y = 0
	}

	return pt
}

// show translates the given origin point, paints the appropriate part of the
// current image to the canvas, and sets the name of the window.
// (Painting only paints the sub-image that is viewable.)
func (c *canv) show() {
	for i, win := range c.wins {
		// If there's no valid image, don't bother trying to show it.
		// (We're hopefully loading the image now.)
		if c.imgs[i] != nil {
			// Now paint the sub-image to the window.
			win.paint(c.imgs[i].SubImage(image.Rect(c.origin.X, c.origin.Y,
				c.origin.X+win.Geom.Width(), c.origin.Y+win.Geom.Height())))

			// Always set the name of the window when we update it with a new image.
			win.nameSet(fmt.Sprintf("%d %s (%dx%d)", i, c.name, c.imgs[i].Bounds().Dx(), c.imgs[i].Bounds().Dy()))
		} else {
			// TODO draw black
			// win.paint(c.imgs[i].SubImage(image.Rect(c.origin.X, c.origin.Y,
			// c.origin.X+win.Geom.Width(), c.origin.Y+win.Geom.Height())))
		}
	}
}

func draw(ximg *xgraphics.Image) *xgraphics.Image {
	// start := time.Now()
	newximg := *ximg

	/*
	newximg.Rect.Max.X *= 2
	newximg.Rect.Max.Y *= 2
	newximg.Pix = imagelib.ScaleUpPackedQuad(ximg.Pix, ximg.Stride)
	newximg.Stride *= 2

	newximg.Rect.Max.X *= 2
	newximg.Rect.Max.Y *= 2
	newximg.Pix = imagelib.ScaleUpPackedQuad(newximg.Pix, newximg.Stride)
	newximg.Stride *= 2
	*/

	if err := newximg.CreatePixmap(); err != nil {
		glog.Fatal(err)
	}
	newximg.XDraw()
	return &newximg
}
