package vlib

import (
	"fmt"
	"image"
	"time"

	"github.com/BurntSushi/xgbutil"
	"github.com/BurntSushi/xgbutil/xgraphics"
)

var imgs = []*xgraphics.Image{}

// chans is a group of channels used to communicate with the canvas goroutine.
type chans struct {
	// drawChan is sent a function that transforms the current origin point
	// and paints the image generated by that origin.
	drawChan chan func(pt image.Point) image.Point

	// resizeToImageChan, when pinged, will resize the window to fit the
	// current image exactly.
	resizeToImageChan chan struct{}

	// prevImg can be pinged to cycle to the previous image. It wraps.
	prevImg chan struct{}

	// nextImg can be pinged to cycle to the next image. It wraps.
	nextImg chan struct{}

	// prevVal can be pinged to cycle to the previous value.
	prevVal chan struct{}

	// nextVal can be pinged to cycle to the next value.
	nextVal chan struct{}

	// The pan{Start,Step,End}Chan types facilitate panning. They correspond
	// to "drag start", "drag step", and "drag end."
	panStartChan chan image.Point
	panStepChan  chan image.Point
	panEndChan   chan image.Point
}

type ImageFetcher func(i int) (int, []image.Image)

// canvas is meant to be run as a single goroutine that maintains the state
// of the image viewer. It manipulates state by reading values from the channels
// defined in the 'chans' type.
func Canvas(X *xgbutil.XUtil, getImages ImageFetcher) chans {
	var wins []*window
	drawChan := make(chan func(pt image.Point) image.Point, 0)
	resizeToImageChan := make(chan struct{}, 0)
	prevImg := make(chan struct{}, 0)
	nextImg := make(chan struct{}, 0)
	prevVal := make(chan struct{}, 0)
	nextVal := make(chan struct{}, 0)

	panStartChan := make(chan image.Point, 0)
	panStepChan := make(chan image.Point, 0)
	panEndChan := make(chan image.Point, 0)
	panStart, panOrigin := image.Point{}, image.Point{}

	chans := chans{
		drawChan:          drawChan,
		resizeToImageChan: resizeToImageChan,
		prevImg:           prevImg,
		nextImg:           nextImg,
		prevVal:           prevVal,
		nextVal:           nextVal,

		panStartChan: panStartChan,
		panStepChan:  panStepChan,
		panEndChan:   panEndChan,
	}

	clearimgs := func() {
		for i := range imgs {
			if imgs[i] != nil {
				imgs[i].Destroy()
				imgs[i] = nil
			}
		}
	}
	defer func() { clearimgs() }()

	current := 0 // flagStartFrame
	arg1 := 111
	origin := image.Point{0, 0}
	name := ""

	setImage := func(i int, pt image.Point) {
		lg("setImage %d", i)
		start := time.Now()
		if current != i || len(imgs) == 0 {
			newi, newimgs := getImages(i)
			current = newi

			//	window.ClearAll()
			clearimgs()
			imgs = imgs[:0]

			// info := curimg.Src.Info
			// name = fmt.Sprintf("%d %s t=%d", info.Imgid, info.Creation.Format("05.999"), arg1)

			for _, img := range newimgs {
				imgs = append(imgs, draw(xgraphics.NewConvert(X, img)))
			}
			// }
		}
		if len(wins) == 0 {
			for i := 0; i < len(imgs); i++ {
				win := newWindow(X, imgs[i].Bounds().Dx(), imgs[i].Bounds().Dy())
				win.setupEventHandlers(chans)
				wins = append(wins, win)
			}
		}

		//if imgs[i] == nil {
		//  window.nameSet(fmt.Sprintf("%s - Loading...", names[i]))
		//	return
		//}

		if pt != image.ZP && pt != origin {
			origin = originTrans(pt, wins[0], imgs[0])
		}
		show(wins, name, imgs, origin)
		logsince(start, "end setImage %d", i)
	}

	go func() {
		setImage(current, origin)
		for {
			sstart := time.Now()
			select {
			case funpt := <-drawChan:
				logsince(sstart, "received draw request %v", funpt)
				setImage(current, funpt(origin))
			case <-resizeToImageChan:
				logsince(sstart, "received resize request request")
				rect := imgs[0].Bounds()
				for _, win := range wins {
					win.Resize(rect.Dx(), rect.Dy())
				}
			case <-prevImg:
				logsince(sstart, "received prevImg request")
				setImage(current-1, origin)
			case <-nextImg:
				logsince(sstart, "received nextImg request")
				setImage(current+1, origin)
			case <-prevVal:
				logsince(sstart, "received prevVal request")
				arg1--
				c := current
				current = -1
				setImage(c, origin)
			case <-nextVal:
				logsince(sstart, "received nextVal request")
				arg1++
				c := current
				current = -1
				setImage(c, origin)
			case pt := <-panStartChan:
				panStart = pt
				panOrigin = origin
			case pt := <-panStepChan:
				xd, yd := panStart.X-pt.X, panStart.Y-pt.Y
				setImage(current,
					image.Point{xd + panOrigin.X, yd + panOrigin.Y})
			case <-panEndChan:
				panStart, panOrigin = image.Point{}, image.Point{}
			}
		}
	}()

	return chans
}

// originTrans translates the origin with respect to the current image and the
// current canvas size. This makes sure we never incorrect position the image.
// (i.e., panning never goes too far, and whenever the canvas is bigger than
// the image, the origin is *always* (0, 0).
func originTrans(pt image.Point, win *window, img *xgraphics.Image) image.Point {
	// If there's no valid image, then always return (0, 0).
	if img == nil {
		return image.Point{0, 0}
	}

	// Quick aliases.
	ww, wh := win.Geom.Width(), win.Geom.Height()
	dw := img.Bounds().Dx() - ww
	dh := img.Bounds().Dy() - wh

	// Set the allowable range of the origin point of the image.
	// i.e., never less than (0, 0) and never greater than the width/height
	// of the image that isn't viewable at any given point (which is determined
	// by the canvas size).
	pt.X = min(img.Bounds().Min.X+dw, max(pt.X, 0))
	pt.Y = min(img.Bounds().Min.Y+dh, max(pt.Y, 0))

	// Validate origin point. If the width/height of an image is smaller than
	// the canvas width/height, then the image origin cannot change in x/y
	// direction.
	if img.Bounds().Dx() < ww {
		pt.X = 0
	}
	if img.Bounds().Dy() < wh {
		pt.Y = 0
	}

	return pt
}

// show translates the given origin point, paints the appropriate part of the
// current image to the canvas, and sets the name of the window.
// (Painting only paints the sub-image that is viewable.)
func show(wins []*window, name string, ximgs []*xgraphics.Image, pt image.Point) {
	for i, win := range wins {
		// If there's no valid image, don't bother trying to show it.
		// (We're hopefully loading the image now.)
		if ximgs[i] != nil {
			// Now paint the sub-image to the window.
			win.paint(ximgs[i].SubImage(image.Rect(pt.X, pt.Y,
				pt.X+win.Geom.Width(), pt.Y+win.Geom.Height())))

			// Always set the name of the window when we update it with a new image.
			win.nameSet(fmt.Sprintf("%d %s (%dx%d)", i, name, ximgs[i].Bounds().Dx(), ximgs[i].Bounds().Dy()))
		} else {
			// TODO draw black
			// win.paint(ximgs[i].SubImage(image.Rect(pt.X, pt.Y,
			// pt.X+win.Geom.Width(), pt.Y+win.Geom.Height())))
		}
	}
}

func draw(ximg *xgraphics.Image) *xgraphics.Image {
	// start := time.Now()
	newximg := *ximg

	/*
	newximg.Rect.Max.X *= 2
	newximg.Rect.Max.Y *= 2
	newximg.Pix = imagelib.ScaleUpPackedQuad(ximg.Pix, ximg.Stride)
	newximg.Stride *= 2

	newximg.Rect.Max.X *= 2
	newximg.Rect.Max.Y *= 2
	newximg.Pix = imagelib.ScaleUpPackedQuad(newximg.Pix, newximg.Stride)
	newximg.Stride *= 2
	*/

	if err := newximg.CreatePixmap(); err != nil {
		errLg.Fatal(err)
	}
	newximg.XDraw()
	return &newximg
}
